// Copyright (c) The Tellor Authors.
// Licensed under the MIT License.

package main

import (
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"text/template"
	"time"

	"github.com/pkg/errors"
)

const (
	sourceDir  = "sources"
	headerFile = "header.c"
	kernelFile = "kernel.cl"
)

var resultFile = filepath.Join("pkg", "pow", "kernelSource.go")

// This program compiles all the opencl code into a single string
// which is then baked into the final go executable

func compileSources() (string, error) {
	_, filename, _, ok := runtime.Caller(0)
	if !ok {
		return "", errors.Errorf("couldn't find opencl source directory")
	}

	dir := filepath.Join(filepath.Dir(filename), sourceDir)
	files, err := ioutil.ReadDir(dir)
	if err != nil {
		return "", errors.Wrapf(err, "read directory: %s", dir)
	}

	contents := make(map[string][]byte)
	for _, file := range files {
		filepath := filepath.Join(dir, file.Name())
		data, err := ioutil.ReadFile(filepath)
		if err != nil {
			return "", errors.Wrapf(err, "read file: %s", filepath)
		}
		contents[file.Name()] = data
	}
	var out strings.Builder
	if _, ok := contents[headerFile]; !ok {
		return "", errors.Wrapf(err, "missing %s file", headerFile)
	}
	out.Write(contents[headerFile])
	delete(contents, headerFile)

	mainSrc, ok := contents[kernelFile]
	if !ok {
		return "", errors.Wrapf(err, "missing %s file", kernelFile)
	}
	delete(contents, kernelFile)

	for _, data := range contents {
		out.Write(data)
	}
	out.Write(mainSrc)

	return out.String(), nil
}

func main() {
	kernelStr, err := compileSources()
	if err != nil {
		log.Fatal("failed to compile opencl sources", err.Error())
	}

	outFile, err := os.Create(resultFile)
	if err != nil {
		log.Fatalf("failed to create output file: %s: %s\n", resultFile, err.Error())
	}
	defer outFile.Close()

	err = packageTemplate.Execute(outFile, struct {
		Timestamp time.Time
		Directory string
		Source    string
	}{
		Timestamp: time.Now(),
		Directory: sourceDir,
		Source:    kernelStr,
	})
	if err != nil {
		log.Fatal("failed to execute template", err.Error())
	}
}

var packageTemplate = template.Must(template.New("").Parse(`
// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at
// {{ .Timestamp }}
// using data from {{ .Directory }}
package pow

const KernelSource = ` + "`" + `
{{ .Source }}
` + "`"))
